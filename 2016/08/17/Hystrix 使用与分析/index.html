<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="一:为什么需要Hystrix?在大中型分布式系统中，通常系统很多依赖(HTTP,hessian,Netty,Dubbo等)，如下图:
在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等.如下图：QPS为50的依赖 I 出现不可用，但是其他依赖仍然可用.">
<meta property="og:type" content="article">
<meta property="og:title" content="Hystrix 使用与分析">
<meta property="og:url" content="http://yoursite.com/2016/08/17/Hystrix 使用与分析/index.html">
<meta property="og:site_name" content="sohutv">
<meta property="og:description" content="一:为什么需要Hystrix?在大中型分布式系统中，通常系统很多依赖(HTTP,hessian,Netty,Dubbo等)，如下图:
在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等.如下图：QPS为50的依赖 I 出现不可用，但是其他依赖仍然可用.">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1493878-1a06b4f0f6c8112d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1493878-b0287878f578f531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://i2.itc.cn/20160816/3084_217c6245_eb48_2b1f_19c8_cd1d5ab2dd45_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_df6f7c9a_6256_70f3_e679_4f5d15e7887f_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160816/3084_365f0bf8_e447_0891_e1ee_74c17382f750_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160816/3084_af562c33_0df0_77dc_3b0e_7d510476ad5b_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_c87cba99_dfe9_0a7f_c1f4_70b079448590_1.png">
<meta property="og:image" content="http://i2.itc.cn/20160816/3084_bbf12e83_e95b_9474_fabb_29d63f6cd61a_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_b0b9ca31_a996_8c39_2200_6cd036565576_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_1ecdbc16_5438_62ad_13a3_8e3baa380f47_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160816/3084_2ca7bd62_9ae9_51f3_e7db_3482e52856c4_1.jpg">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_f28d342a_faf8_cfc7_de53_3cbfae9efeec_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160816/3084_323c1e07_1bca_58f8_04fc_759d33087ccf_1.png">
<meta property="og:updated_time" content="2016-08-16T15:43:02.423Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hystrix 使用与分析">
<meta name="twitter:description" content="一:为什么需要Hystrix?在大中型分布式系统中，通常系统很多依赖(HTTP,hessian,Netty,Dubbo等)，如下图:
在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等.如下图：QPS为50的依赖 I 出现不可用，但是其他依赖仍然可用.">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1493878-1a06b4f0f6c8112d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Hystrix 使用与分析 | sohutv </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?259be27fbdaccd97ee659bc4dfe21524";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">sohutv</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Hystrix 使用与分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-17T09:20:24+08:00" content="2016-08-17">
              2016-08-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/netflix/" itemprop="url" rel="index">
                    <span itemprop="name">netflix</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/17/Hystrix 使用与分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/17/Hystrix 使用与分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一-为什么需要Hystrix"><a href="#一-为什么需要Hystrix" class="headerlink" title="一:为什么需要Hystrix?"></a>一:为什么需要Hystrix?</h3><p>在大中型分布式系统中，通常系统很多依赖(HTTP,hessian,Netty,Dubbo等)，如下图:<br><img src="http://upload-images.jianshu.io/upload_images/1493878-1a06b4f0f6c8112d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在高并发访问下,这些依赖的稳定性与否对系统的影响非常大,但是依赖有很多不可控问题:如网络连接缓慢，资源繁忙，暂时不可用，服务脱机等.<br>如下图：QPS为50的依赖 I 出现不可用，但是其他依赖仍然可用.<br><img src="http://upload-images.jianshu.io/upload_images/1493878-b0287878f578f531.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<p>当依赖I 阻塞时,大多数服务器的线程池就出现阻塞(BLOCK),影响整个线上服务的稳定性.如下图:<br><img src="http://i2.itc.cn/20160816/3084_217c6245_eb48_2b1f_19c8_cd1d5ab2dd45_1.png" alt=""></p>
<p>在复杂的分布式架构的应用程序有很多的依赖，都会不可避免地在某些时候失败。高并发的依赖失败时如果没有隔离措施，当前应用服务就有被拖垮的风险。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如:一个依赖30个SOA服务的系统,每个服务99.99%可用。</span><br><span class="line">99.99%的30次方 ≈ 99.7%</span><br><span class="line">0.3% 意味着一亿次请求 会有 3,000,00次失败</span><br><span class="line">换算成时间大约每月有2个小时服务不稳定.</span><br><span class="line">随着服务依赖数量的变多，服务不稳定的概率会成指数性提高.</span><br></pre></td></tr></table></figure>
<p>解决问题方案:对依赖做隔离,Hystrix就是处理依赖隔离的框架,同时也是可以帮我们做依赖服务的治理和监控.<br>Netflix 公司开发并成功使用Hystrix,使用规模如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The Netflix API processes 10+ billion HystrixCommand executions per day using thread isolation. </span><br><span class="line">Each API instance has 40+ thread-pools with 5-20 threads in each (most are set to 10).</span><br></pre></td></tr></table></figure>
<h3 id="二-Hystrix如何解决依赖隔离"><a href="#二-Hystrix如何解决依赖隔离" class="headerlink" title="二:Hystrix如何解决依赖隔离"></a>二:Hystrix如何解决依赖隔离</h3><ul>
<li>1:Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。</li>
<li>2:可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li>
<li>3:为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li>
<li>4:依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li>
<li>5:提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li>
<li>6:提供近实时依赖的统计和监控</li>
</ul>
<p>Hystrix依赖的隔离架构,如下图:<br><img src="http://i3.itc.cn/20160816/3084_df6f7c9a_6256_70f3_e679_4f5d15e7887f_1.png" alt=""></p>
<h3 id="三-如何使用Hystrix"><a href="#三-如何使用Hystrix" class="headerlink" title="三:如何使用Hystrix"></a>三:如何使用Hystrix</h3><h4 id="1-使用maven引入Hystrix依赖"><a href="#1-使用maven引入Hystrix依赖" class="headerlink" title="1:使用maven引入Hystrix依赖"></a>1:使用maven引入Hystrix依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 依赖版本 --&gt;</span><br><span class="line">&lt;hystrix.version&gt;1.3.16&lt;/hystrix.version&gt;</span><br><span class="line">&lt;hystrix-metrics-event-stream.version&gt;1.1.2&lt;/hystrix-metrics-event-stream.version&gt; </span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;hystrix.version&#125;&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;hystrix-metrics-event-stream&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;hystrix-metrics-event-stream.version&#125;&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;!-- 仓库地址 --&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">     &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">     &lt;name&gt;local private nexus&lt;/name&gt;</span><br><span class="line">     &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt;</span><br><span class="line">     &lt;releases&gt;</span><br><span class="line">          &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">     &lt;/releases&gt;</span><br><span class="line">     &lt;snapshots&gt;</span><br><span class="line">          &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">     &lt;/snapshots&gt;</span><br><span class="line">&lt;/repository&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用命令模式封装依赖逻辑"><a href="#2-使用命令模式封装依赖逻辑" class="headerlink" title="2:使用命令模式封装依赖逻辑"></a>2:使用命令模式封装依赖逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    public HelloWorldCommand(String name) &#123;</span><br><span class="line">        //最少配置:指定命令组名(CommandGroup)</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;));</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String run() &#123;</span><br><span class="line">        // 依赖逻辑封装在run()方法中</span><br><span class="line">        return &quot;Hello &quot; + name +&quot; thread:&quot; + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    //调用实例</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        //每个Command对象只能调用一次,不可以重复调用,</span><br><span class="line">        //重复调用对应异常信息:This instance can only be executed once. Please instantiate a new instance.</span><br><span class="line">        HelloWorldCommand helloWorldCommand = new HelloWorldCommand(&quot;Synchronous-hystrix&quot;);</span><br><span class="line">        //使用execute()同步调用代码,效果等同于:helloWorldCommand.queue().get(); </span><br><span class="line">        String result = helloWorldCommand.execute();</span><br><span class="line">        System.out.println(&quot;result=&quot; + result);</span><br><span class="line"> </span><br><span class="line">        helloWorldCommand = new HelloWorldCommand(&quot;Asynchronous-hystrix&quot;);</span><br><span class="line">        //异步调用,可自由控制获取结果时机,</span><br><span class="line">        Future&lt;String&gt; future = helloWorldCommand.queue();</span><br><span class="line">        //get操作不能超过command定义的超时时间,默认:1秒</span><br><span class="line">        result = future.get(100, TimeUnit.MILLISECONDS);</span><br><span class="line">        System.out.println(&quot;result=&quot; + result);</span><br><span class="line">        System.out.println(&quot;mainThread=&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">    //运行结果: run()方法在不同的线程下执行</span><br><span class="line">    // result=Hello Synchronous-hystrix thread:hystrix-HelloWorldGroup-1</span><br><span class="line">    // result=Hello Asynchronous-hystrix thread:hystrix-HelloWorldGroup-2</span><br><span class="line">    // mainThread=main</span><br><span class="line">note:异步调用使用 command.queue()get(timeout, TimeUnit.MILLISECONDS);同步调用使用command.execute() 等同于 command.queue().get();</span><br></pre></td></tr></table></figure>
<h4 id="3-注册异步事件回调执行"><a href="#3-注册异步事件回调执行" class="headerlink" title="3:注册异步事件回调执行"></a>3:注册异步事件回调执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//注册观察者事件拦截</span><br><span class="line">Observable&lt;String&gt; fs = new HelloWorldCommand(&quot;World&quot;).observe();</span><br><span class="line">//注册结果回调事件</span><br><span class="line">fs.subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(String result) &#123;</span><br><span class="line">         //执行结果处理,result 为HelloWorldCommand返回的结果</span><br><span class="line">        //用户对结果做二次处理.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//注册完整执行生命周期事件</span><br><span class="line">fs.subscribe(new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">                // onNext/onError完成之后最后回调</span><br><span class="line">                System.out.println(&quot;execute onCompleted&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                // 当产生异常时回调</span><br><span class="line">                System.out.println(&quot;onError &quot; + e.getMessage());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(String v) &#123;</span><br><span class="line">                // 获取结果后回调</span><br><span class="line">                System.out.println(&quot;onNext: &quot; + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">/* 运行结果</span><br><span class="line">call execute result=Hello observe-hystrix thread:hystrix-HelloWorldGroup-3</span><br><span class="line">onNext: Hello observe-hystrix thread:hystrix-HelloWorldGroup-3</span><br><span class="line">execute onCompleted</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="4-使用Fallback-提供降级策略"><a href="#4-使用Fallback-提供降级策略" class="headerlink" title="4:使用Fallback() 提供降级策略"></a>4:使用Fallback() 提供降级策略</h4><p><img src="http://i0.itc.cn/20160816/3084_365f0bf8_e447_0891_e1ee_74c17382f750_1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//重载HystrixCommand 的getFallback方法实现逻辑</span><br><span class="line">public class HelloWorldCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    public HelloWorldCommand(String name) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;HelloWorldGroup&quot;))</span><br><span class="line">                /* 配置依赖超时时间,500毫秒*/</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionIsolationThreadTimeoutInMilliseconds(500)));</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getFallback() &#123;</span><br><span class="line">        return &quot;exeucute Falled&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String run() throws Exception &#123;</span><br><span class="line">        //sleep 1 秒,调用会超时</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(1000);</span><br><span class="line">        return &quot;Hello &quot; + name +&quot; thread:&quot; + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        HelloWorldCommand command = new HelloWorldCommand(&quot;test-Fallback&quot;);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 运行结果:getFallback() 调用运行</span><br><span class="line">getFallback executed</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE: 除了HystrixBadRequestException异常之外，所有从run()方法抛出的异常都算作失败，并触发降级getFallback()和断路器逻辑。<br>HystrixBadRequestException用在非法参数或非系统故障异常等不应触发回退逻辑的场景。</em></strong></p>
<h4 id="5-依赖命名-CommandKey"><a href="#5-依赖命名-CommandKey" class="headerlink" title="5:依赖命名:CommandKey"></a>5:依赖命名:CommandKey</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public HelloWorldCommand(String name) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))</span><br><span class="line">                /* HystrixCommandKey工厂定义依赖名称 */</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;)));</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE: 每个CommandKey代表一个依赖抽象,相同的依赖要使用相同的CommandKey名称。依赖隔离的根本就是对相同CommandKey的依赖做隔离.</em></strong></p>
<h4 id="6-依赖分组-CommandGroup"><a href="#6-依赖分组-CommandGroup" class="headerlink" title="6:依赖分组:CommandGroup"></a>6:依赖分组:CommandGroup</h4><p>命令分组用于对依赖操作分组,便于统计,汇总等.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用HystrixCommandGroupKey工厂定义</span><br><span class="line">public HelloWorldCommand(String name) &#123;</span><br><span class="line">    Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;HelloWorldGroup&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE: CommandGroup是每个命令最少配置的必选参数，在不指定ThreadPoolKey的情况下，字面值用于对不同依赖的线程池/信号区分.</em></strong></p>
<h4 id="7-线程池-信号-ThreadPoolKey"><a href="#7-线程池-信号-ThreadPoolKey" class="headerlink" title="7:线程池/信号:ThreadPoolKey"></a>7:线程池/信号:ThreadPoolKey</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HelloWorldCommand(String name) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;HelloWorld&quot;))</span><br><span class="line">                /* 使用HystrixThreadPoolKey工厂定义线程池名称*/</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;HelloWorldPool&quot;)));</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE: 当对同一业务依赖做隔离时使用CommandGroup做区分,但是对同一依赖的不同远程调用如(一个是redis 一个是http),可以使用HystrixThreadPoolKey做隔离区分.最然在业务上都是相同的组，但是需要在资源上做隔离时，可以使用HystrixThreadPoolKey区分.</em></strong></p>
<h4 id="8-请求缓存-Request-Cache"><a href="#8-请求缓存-Request-Cache" class="headerlink" title="8:请求缓存 Request-Cache"></a>8:请求缓存 Request-Cache</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class RequestCacheCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final int id;</span><br><span class="line">    public RequestCacheCommand( int id) &#123;</span><br><span class="line">        super(HystrixCommandGroupKey.Factory.asKey(&quot;RequestCacheCommand&quot;));</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String run() throws Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; execute id=&quot; + id);</span><br><span class="line">        return &quot;executed=&quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写getCacheKey方法,实现区分不同请求的逻辑</span><br><span class="line">    @Override</span><br><span class="line">    protected String getCacheKey() &#123;</span><br><span class="line">        return String.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            RequestCacheCommand command2a = new RequestCacheCommand(2);</span><br><span class="line">            RequestCacheCommand command2b = new RequestCacheCommand(2);</span><br><span class="line">            Assert.assertTrue(command2a.execute());</span><br><span class="line">            //isResponseFromCache判定是否是在缓存中获取结果</span><br><span class="line">            Assert.assertFalse(command2a.isResponseFromCache());</span><br><span class="line">            Assert.assertTrue(command2b.execute());</span><br><span class="line">            Assert.assertTrue(command2b.isResponseFromCache());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        context = HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            RequestCacheCommand command3b = new RequestCacheCommand(2);</span><br><span class="line">            Assert.assertTrue(command3b.execute());</span><br><span class="line">            Assert.assertFalse(command3b.isResponseFromCache());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE:请求缓存可以让(CommandKey/CommandGroup)相同的情况下,直接共享结果，降低依赖调用次数，在高并发和CacheKey碰撞率高场景下可以大幅提升性能.Servlet容器中，可以直接实用Filter机制Hystrix请求上下文</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HystrixRequestContextServletFilter implements Filter &#123;</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) </span><br><span class="line">     throws IOException, ServletException &#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">      &lt;display-name&gt;HystrixRequestContextServletFilter&lt;/display-name&gt;</span><br><span class="line">      &lt;filter-name&gt;HystrixRequestContextServletFilter&lt;/filter-name&gt;</span><br><span class="line">      &lt;filter-class&gt;com.netflix.hystrix.contrib.requestservlet.HystrixRequestContextServletFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">      &lt;filter-name&gt;HystrixRequestContextServletFilter&lt;/filter-name&gt;</span><br><span class="line">      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">   &lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="9-信号量隔离-SEMAPHORE"><a href="#9-信号量隔离-SEMAPHORE" class="headerlink" title="9:信号量隔离:SEMAPHORE"></a>9:信号量隔离:SEMAPHORE</h4><p>隔离本地代码或可快速返回远程调用(如memcached,redis)可以直接使用信号量隔离,降低线程隔离开销.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public class HelloWorldCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    public HelloWorldCommand(String name) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;HelloWorldGroup&quot;))</span><br><span class="line">                /* 配置信号量隔离方式,默认采用线程池隔离 */</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)));</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String run() throws Exception &#123;</span><br><span class="line">        return &quot;HystrixThread:&quot; + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        HelloWorldCommand command = new HelloWorldCommand(&quot;semaphore&quot;);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(&quot;MainThread:&quot; + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/** 运行结果</span><br><span class="line"> HystrixThread:main</span><br><span class="line"> MainThread:main</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="10-fallback降级逻辑命令嵌套"><a href="#10-fallback降级逻辑命令嵌套" class="headerlink" title="10:fallback降级逻辑命令嵌套"></a>10:fallback降级逻辑命令嵌套</h4><p><img src="http://i1.itc.cn/20160816/3084_af562c33_0df0_77dc_3b0e_7d510476ad5b_1.png" alt=""></p>
<p>适用场景:用于fallback逻辑涉及网络访问的情况,如缓存访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class CommandWithFallbackViaNetwork extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final int id;</span><br><span class="line"> </span><br><span class="line">    protected CommandWithFallbackViaNetwork(int id) &#123;</span><br><span class="line">        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;RemoteServiceX&quot;))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GetValueCommand&quot;)));</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected String run() &#123;</span><br><span class="line">        // RemoteService.getValue(id);</span><br><span class="line">        throw new RuntimeException(&quot;force failure for example&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected String getFallback() &#123;</span><br><span class="line">        return new FallbackViaNetwork(id).execute();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static class FallbackViaNetwork extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">        private final int id;</span><br><span class="line"> </span><br><span class="line">        public FallbackViaNetwork(int id) &#123;</span><br><span class="line">            super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;RemoteServiceX&quot;))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GetValueFallbackCommand&quot;))</span><br><span class="line">                    // 使用不同的线程池做隔离，防止上层线程池跑满，影响降级逻辑.</span><br><span class="line">                    .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;RemoteServiceXFallback&quot;)));</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        protected String run() &#123;</span><br><span class="line">            MemCacheClient.getValue(id);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @Override</span><br><span class="line">        protected String getFallback() &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE:依赖调用和降级调用使用不同的线程池做隔离，防止上层线程池跑满，影响二级降级逻辑调用.</em></strong></p>
<h4 id="11-显示调用fallback逻辑-用于特殊业务处理"><a href="#11-显示调用fallback逻辑-用于特殊业务处理" class="headerlink" title="11:显示调用fallback逻辑,用于特殊业务处理"></a>11:显示调用fallback逻辑,用于特殊业务处理</h4><p><img src="http://i3.itc.cn/20160816/3084_c87cba99_dfe9_0a7f_c1f4_70b079448590_1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class CommandFacadeWithPrimarySecondary extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">    private final static DynamicBooleanProperty usePrimary = DynamicPropertyFactory.getInstance().getBooleanProperty(&quot;primarySecondary.usePrimary&quot;, true);</span><br><span class="line">    private final int id;</span><br><span class="line">    public CommandFacadeWithPrimarySecondary(int id) &#123;</span><br><span class="line">        super(Setter</span><br><span class="line">                .withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;SystemX&quot;))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;PrimarySecondaryCommand&quot;))</span><br><span class="line">                .andCommandPropertiesDefaults(</span><br><span class="line">                        HystrixCommandProperties.Setter()</span><br><span class="line">                                .withExecutionIsolationStrategy(ExecutionIsolationStrategy.SEMAPHORE)));</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String run() &#123;</span><br><span class="line">        if (usePrimary.get()) &#123;</span><br><span class="line">            return new PrimaryCommand(id).execute();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new SecondaryCommand(id).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getFallback() &#123;</span><br><span class="line">        return &quot;static-fallback-&quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String getCacheKey() &#123;</span><br><span class="line">        return String.valueOf(id);</span><br><span class="line">    &#125;</span><br><span class="line">    private static class PrimaryCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">        private final int id;</span><br><span class="line">        private PrimaryCommand(int id) &#123;</span><br><span class="line">            super(Setter</span><br><span class="line">                    .withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;SystemX&quot;))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;PrimaryCommand&quot;))</span><br><span class="line">                    .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;PrimaryCommand&quot;))</span><br><span class="line">                    .andCommandPropertiesDefaults(</span><br><span class="line">                            // we default to a 600ms timeout for primary</span><br><span class="line">                            HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(600)));</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected String run() &#123;</span><br><span class="line">            // perform expensive &apos;primary&apos; service call</span><br><span class="line">            return &quot;responseFromPrimary-&quot; + id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class SecondaryCommand extends HystrixCommand&lt;String&gt; &#123;</span><br><span class="line">        private final int id;</span><br><span class="line">        private SecondaryCommand(int id) &#123;</span><br><span class="line">            super(Setter</span><br><span class="line">                    .withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;SystemX&quot;))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;SecondaryCommand&quot;))</span><br><span class="line">                    .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;SecondaryCommand&quot;))</span><br><span class="line">                    .andCommandPropertiesDefaults(</span><br><span class="line">                            // we default to a 100ms timeout for secondary</span><br><span class="line">                            HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(100)));</span><br><span class="line">            this.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected String run() &#123;</span><br><span class="line">            // perform fast &apos;secondary&apos; service call</span><br><span class="line">            return &quot;responseFromSecondary-&quot; + id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class UnitTest &#123;</span><br><span class="line">        @Test</span><br><span class="line">        public void testPrimary() &#123;</span><br><span class="line">            HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">            try &#123;</span><br><span class="line">                ConfigurationManager.getConfigInstance().setProperty(&quot;primarySecondary.usePrimary&quot;, true);</span><br><span class="line">                assertEquals(&quot;responseFromPrimary-20&quot;, new CommandFacadeWithPrimarySecondary(20).execute());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                context.shutdown();</span><br><span class="line">                ConfigurationManager.getConfigInstance().clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Test</span><br><span class="line">        public void testSecondary() &#123;</span><br><span class="line">            HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">            try &#123;</span><br><span class="line">                ConfigurationManager.getConfigInstance().setProperty(&quot;primarySecondary.usePrimary&quot;, false);</span><br><span class="line">                assertEquals(&quot;responseFromSecondary-20&quot;, new CommandFacadeWithPrimarySecondary(20).execute());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                context.shutdown();</span><br><span class="line">                ConfigurationManager.getConfigInstance().clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE:显示调用降级适用于特殊需求的场景,fallback用于业务处理，fallback不再承担降级职责，建议慎重使用，会造成监控统计换乱等问题.</em></strong></p>
<h4 id="12-命令调用合并-HystrixCollapser"><a href="#12-命令调用合并-HystrixCollapser" class="headerlink" title="12:命令调用合并:HystrixCollapser"></a>12:命令调用合并:HystrixCollapser</h4><p>命令调用合并允许多个请求合并到一个线程/信号下批量执行。执行流程图如下:<br><img src="http://i2.itc.cn/20160816/3084_bbf12e83_e95b_9474_fabb_29d63f6cd61a_1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class CommandCollapserGetValueForKey extends HystrixCollapser&lt;List&lt;String&gt;, String, Integer&gt; &#123;</span><br><span class="line">    private final Integer key;</span><br><span class="line">    public CommandCollapserGetValueForKey(Integer key) &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer getRequestArgument() &#123;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected HystrixCommand&lt;List&lt;String&gt;&gt; createCommand(final Collection&lt;CollapsedRequest&lt;String, Integer&gt;&gt; requests) &#123;</span><br><span class="line">        //创建返回command对象</span><br><span class="line">        return new BatchCommand(requests);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void mapResponseToRequests(List&lt;String&gt; batchResponse, Collection&lt;CollapsedRequest&lt;String, Integer&gt;&gt; requests) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (CollapsedRequest&lt;String, Integer&gt; request : requests) &#123;</span><br><span class="line">            //手动匹配请求和响应</span><br><span class="line">            request.setResponse(batchResponse.get(count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static final class BatchCommand extends HystrixCommand&lt;List&lt;String&gt;&gt; &#123;</span><br><span class="line">        private final Collection&lt;CollapsedRequest&lt;String, Integer&gt;&gt; requests;</span><br><span class="line">        private BatchCommand(Collection&lt;CollapsedRequest&lt;String, Integer&gt;&gt; requests) &#123;</span><br><span class="line">                super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;))</span><br><span class="line">                    .andCommandKey(HystrixCommandKey.Factory.asKey(&quot;GetValueForKey&quot;)));</span><br><span class="line">            this.requests = requests;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected List&lt;String&gt; run() &#123;</span><br><span class="line">            ArrayList&lt;String&gt; response = new ArrayList&lt;String&gt;();</span><br><span class="line">            for (CollapsedRequest&lt;String, Integer&gt; request : requests) &#123;</span><br><span class="line">                response.add(&quot;ValueForKey: &quot; + request.getArgument());</span><br><span class="line">            &#125;</span><br><span class="line">            return response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class UnitTest &#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        try &#123;</span><br><span class="line">            Future&lt;String&gt; f1 = new CommandCollapserGetValueForKey(1).queue();</span><br><span class="line">            Future&lt;String&gt; f2 = new CommandCollapserGetValueForKey(2).queue();</span><br><span class="line">            Future&lt;String&gt; f3 = new CommandCollapserGetValueForKey(3).queue();</span><br><span class="line">            Future&lt;String&gt; f4 = new CommandCollapserGetValueForKey(4).queue();</span><br><span class="line">            assertEquals(&quot;ValueForKey: 1&quot;, f1.get());</span><br><span class="line">            assertEquals(&quot;ValueForKey: 2&quot;, f2.get());</span><br><span class="line">            assertEquals(&quot;ValueForKey: 3&quot;, f3.get());</span><br><span class="line">            assertEquals(&quot;ValueForKey: 4&quot;, f4.get());</span><br><span class="line">            assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());</span><br><span class="line">            HystrixCommand&lt;?&gt; command = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand&lt;?&gt;[1])[0];</span><br><span class="line">            assertEquals(&quot;GetValueForKey&quot;, command.getCommandKey().name());</span><br><span class="line">            assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));</span><br><span class="line">            assertTrue(command.getExecutionEvents().contains(HystrixEventType.SUCCESS));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">         context.shutdown();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>NOTE:使用场景:HystrixCollapser用于对多个相同业务的请求合并到一个线程甚至可以合并到一个连接中执行，降低线程交互次和IO数,但必须保证他们属于同一依赖.</em></strong></p>
<h3 id="四-监控平台搭建Hystrix-dashboard"><a href="#四-监控平台搭建Hystrix-dashboard" class="headerlink" title="四:监控平台搭建Hystrix-dashboard"></a>四:监控平台搭建Hystrix-dashboard</h3><h4 id="1-监控dashboard介绍"><a href="#1-监控dashboard介绍" class="headerlink" title="1:监控dashboard介绍"></a>1:监控dashboard介绍</h4><p>dashboard面板可以对依赖关键指标提供实时监控,如下图:<br><img src="http://i3.itc.cn/20160816/3084_b0b9ca31_a996_8c39_2200_6cd036565576_1.png" alt=""></p>
<h4 id="2-实例暴露command统计数据"><a href="#2-实例暴露command统计数据" class="headerlink" title="2:实例暴露command统计数据"></a>2:实例暴露command统计数据</h4><p>Hystrix使用Servlet对当前JVM下所有command调用情况作数据流输出,配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;display-name&gt;HystrixMetricsStreamServlet&lt;/display-name&gt;</span><br><span class="line">    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HystrixMetricsStreamServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/hystrix.stream&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">    对应URL格式 : http://hostname:port/application/hystrix.stream</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-集群模式监控统计搭建"><a href="#3-集群模式监控统计搭建" class="headerlink" title="3:集群模式监控统计搭建"></a>3:集群模式监控统计搭建</h4><h5 id="1-使用Turbine组件做集群数据汇总"><a href="#1-使用Turbine组件做集群数据汇总" class="headerlink" title="1)使用Turbine组件做集群数据汇总"></a>1)使用Turbine组件做集群数据汇总</h5><p>结构图如下:<br><img src="http://i3.itc.cn/20160816/3084_1ecdbc16_5438_62ad_13a3_8e3baa380f47_1.png" alt=""></p>
<h5 id="2-内嵌jetty提供Servlet容器-暴露HystrixMetrics"><a href="#2-内嵌jetty提供Servlet容器-暴露HystrixMetrics" class="headerlink" title="2)内嵌jetty提供Servlet容器,暴露HystrixMetrics"></a>2)内嵌jetty提供Servlet容器,暴露HystrixMetrics</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class JettyServer &#123;</span><br><span class="line">    private final Logger logger = LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    private int port;</span><br><span class="line">    private ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br><span class="line">    private Server server = null;</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            executorService.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //绑定8080端口,加载HystrixMetricsStreamServlet并映射url</span><br><span class="line">                        server = new Server(8080);</span><br><span class="line">                        WebAppContext context = new WebAppContext();</span><br><span class="line">                        context.setContextPath(&quot;/&quot;);</span><br><span class="line">                        context.addServlet(HystrixMetricsStreamServlet.class, &quot;/hystrix.stream&quot;);</span><br><span class="line">                        context.setResourceBase(&quot;.&quot;);</span><br><span class="line">                        server.setHandler(context);</span><br><span class="line">                        server.start();</span><br><span class="line">                        server.join();</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void destory() &#123;</span><br><span class="line">        if (server != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                server.stop();</span><br><span class="line">                server.destroy();</span><br><span class="line">                logger.warn(&quot;jettyServer stop and destroy!&quot;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-Turbine搭建和配置"><a href="#3-Turbine搭建和配置" class="headerlink" title="3)Turbine搭建和配置"></a>3)Turbine搭建和配置</h5><p>a:配置Turbine Servlet收集器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">   &lt;description&gt;&lt;/description&gt;</span><br><span class="line">   &lt;display-name&gt;TurbineStreamServlet&lt;/display-name&gt;</span><br><span class="line">   &lt;servlet-name&gt;TurbineStreamServlet&lt;/servlet-name&gt;</span><br><span class="line">   &lt;servlet-class&gt;com.netflix.turbine.streaming.servlet.TurbineStreamServlet&lt;/servlet-class&gt;</span><br><span class="line"> &lt;/servlet&gt;</span><br><span class="line"> &lt;servlet-mapping&gt;</span><br><span class="line">   &lt;servlet-name&gt;TurbineStreamServlet&lt;/servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;/turbine.stream&lt;/url-pattern&gt;</span><br><span class="line"> &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>b:编写config.properties配置集群实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#配置两个集群:mobil-online,ugc-online</span><br><span class="line">turbine.aggregator.clusterConfig=mobil-online,ugc-online</span><br><span class="line">#配置mobil-online集群实例</span><br><span class="line">turbine.ConfigPropertyBasedDiscovery.mobil-online.instances=10.10.34.11,10.10.34.12,10.10.34.13,10.10.34.14,10.10.34.15,10.10.34.16,10.16.14.52,10.16.14.53,10.16.14.54,10.16.14.55</span><br><span class="line">#配置mobil-online数据流servlet</span><br><span class="line">turbine.instanceUrlSuffix.mobil-online=:8080/hystrix.stream</span><br><span class="line">#配置ugc-online集群实例</span><br><span class="line">turbine.ConfigPropertyBasedDiscovery.ugc-online.instances=10.10.34.198,10.10.52.231,10.10.52.245,10.10.52.246</span><br><span class="line">#配置ugc-online数据流servlet</span><br><span class="line">turbine.instanceUrlSuffix.ugc-online=:8080/hystrix.stream</span><br></pre></td></tr></table></figure>
<p>c:使用Dashboard配置连接Turbine:<br>例如:mobil-online-turbine<br><img src="http://i1.itc.cn/20160816/3084_2ca7bd62_9ae9_51f3_e7db_3482e52856c4_1.jpg" alt=""></p>
<h3 id="五-Hystrix配置与分析"><a href="#五-Hystrix配置与分析" class="headerlink" title="五:Hystrix配置与分析"></a>五:Hystrix配置与分析</h3><h4 id="1-Hystrix-配置"><a href="#1-Hystrix-配置" class="headerlink" title="1:Hystrix 配置"></a>1:Hystrix 配置</h4><h5 id="1-Command-配置"><a href="#1-Command-配置" class="headerlink" title="1):Command 配置"></a>1):Command 配置</h5><p>Command配置源码在HystrixCommandProperties,构造Command时通过Setter进行配置<br>具体配置解释和默认值如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//使用命令调用隔离方式,默认:采用线程隔离,ExecutionIsolationStrategy.THREAD</span><br><span class="line">private final HystrixProperty&lt;ExecutionIsolationStrategy&gt; executionIsolationStrategy; </span><br><span class="line">//使用线程隔离时，调用超时时间，默认:1秒</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; executionIsolationThreadTimeoutInMilliseconds; </span><br><span class="line">//线程池的key,用于决定命令在哪个线程池执行</span><br><span class="line">private final HystrixProperty&lt;String&gt; executionIsolationThreadPoolKeyOverride; </span><br><span class="line">//使用信号量隔离时，命令调用最大的并发数,默认:10</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; executionIsolationSemaphoreMaxConcurrentRequests;</span><br><span class="line">//使用信号量隔离时，命令fallback(降级)调用最大的并发数,默认:10</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; fallbackIsolationSemaphoreMaxConcurrentRequests; </span><br><span class="line">//是否开启fallback降级策略 默认:true </span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; fallbackEnabled; </span><br><span class="line">// 使用线程隔离时，是否对命令执行超时的线程调用中断（Thread.interrupt()）操作.默认:true</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; executionIsolationThreadInterruptOnTimeout; </span><br><span class="line">// 统计滚动的时间窗口,默认:5000毫秒circuitBreakerSleepWindowInMilliseconds</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; metricsRollingStatisticalWindowInMilliseconds;</span><br><span class="line">// 统计窗口的Buckets的数量,默认:10个,每秒一个Buckets统计</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; metricsRollingStatisticalWindowBuckets; // number of buckets in the statisticalWindow</span><br><span class="line">//是否开启监控统计功能,默认:true</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; metricsRollingPercentileEnabled; </span><br><span class="line">// 是否开启请求日志,默认:true</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; requestLogEnabled; </span><br><span class="line">//是否开启请求缓存,默认:true</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; requestCacheEnabled; // Whether request caching is enabled.</span><br></pre></td></tr></table></figure>
<h5 id="2-熔断器（Circuit-Breaker）配置"><a href="#2-熔断器（Circuit-Breaker）配置" class="headerlink" title="2):熔断器（Circuit Breaker）配置"></a>2):熔断器（Circuit Breaker）配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Circuit Breaker配置源码在HystrixCommandProperties,构造Command时通过Setter进行配置,每种依赖使用一个Circuit Breaker</span><br><span class="line">// 熔断器在整个统计时间内是否开启的阀值，默认20秒。也就是10秒钟内至少请求20次，熔断器才发挥起作用</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; circuitBreakerRequestVolumeThreshold; </span><br><span class="line">//熔断器默认工作时间,默认:5秒.熔断器中断请求5秒后会进入半打开状态,放部分流量过去重试</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; circuitBreakerSleepWindowInMilliseconds; </span><br><span class="line">//是否启用熔断器,默认true. 启动</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; circuitBreakerEnabled; </span><br><span class="line">//默认:50%。当出错率超过50%后熔断器启动.</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; circuitBreakerErrorThresholdPercentage;</span><br><span class="line">//是否强制开启熔断器阻断所有请求,默认:false,不开启</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; circuitBreakerForceOpen; </span><br><span class="line">//是否允许熔断器忽略错误,默认false, 不开启</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; circuitBreakerForceClosed;</span><br></pre></td></tr></table></figure>
<h5 id="3-命令合并-Collapser-配置"><a href="#3-命令合并-Collapser-配置" class="headerlink" title="3):命令合并(Collapser)配置"></a>3):命令合并(Collapser)配置</h5><p>Command配置源码在HystrixCollapserProperties,构造Collapser时通过Setter进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//请求合并是允许的最大请求数,默认: Integer.MAX_VALUE</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; maxRequestsInBatch;</span><br><span class="line">//批处理过程中每个命令延迟的时间,默认:10毫秒</span><br><span class="line">private final HystrixProperty&lt;Integer&gt; timerDelayInMilliseconds;</span><br><span class="line">//批处理过程中是否开启请求缓存,默认:开启</span><br><span class="line">private final HystrixProperty&lt;Boolean&gt; requestCacheEnabled;</span><br></pre></td></tr></table></figure>
<h5 id="4-线程池-ThreadPool-配置"><a href="#4-线程池-ThreadPool-配置" class="headerlink" title="4):线程池(ThreadPool)配置"></a>4):线程池(ThreadPool)配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">配置线程池大小,默认值10个.</span><br><span class="line">建议值:请求高峰时99.5%的平均响应时间 + 向上预留一些即可</span><br><span class="line">*/</span><br><span class="line">HystrixThreadPoolProperties.Setter().withCoreSize(int value)</span><br><span class="line">/**</span><br><span class="line">配置线程值等待队列长度,默认值:-1</span><br><span class="line">建议值:-1表示不等待直接拒绝,测试表明线程池使用直接决绝策略+ 合适大小的非回缩线程池效率最高.所以不建议修改此值。</span><br><span class="line">当使用非回缩线程池时，queueSizeRejectionThreshold,keepAliveTimeMinutes 参数无效</span><br><span class="line">*/</span><br><span class="line">HystrixThreadPoolProperties.Setter().withMaxQueueSize(int value)</span><br></pre></td></tr></table></figure>
<h4 id="2-Hystrix关键组件分析"><a href="#2-Hystrix关键组件分析" class="headerlink" title="2:Hystrix关键组件分析"></a>2:Hystrix关键组件分析</h4><h5 id="1-Hystrix流程结构解析"><a href="#1-Hystrix流程结构解析" class="headerlink" title="1):Hystrix流程结构解析"></a>1):Hystrix流程结构解析</h5><p>流程说明:</p>
<ul>
<li>1:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</li>
<li>2:执行execute()/queue做同步或异步调用.</li>
<li>3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤.</li>
<li>4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤.</li>
<li>5:调用HystrixCommand的run方法.运行依赖逻辑<ul>
<li>5a:依赖逻辑调用超时,进入步骤8.</li>
</ul>
</li>
<li>6:判断逻辑是否调用成功<ul>
<li>6a:返回成功调用结果</li>
<li>6b:调用出错，进入步骤8.</li>
</ul>
</li>
<li>7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.</li>
<li>8:getFallback()降级逻辑.以下四种情况将触发getFallback调用：<ul>
<li>(1):run()方法抛出非HystrixBadRequestException异常。</li>
<li>(2):run()方法调用超时</li>
<li>(3):熔断器开启拦截调用</li>
<li>(4):线程池/队列/信号量是否跑满</li>
<li>8a:没有实现getFallback的Command将直接抛出异常</li>
<li>8b:fallback降级逻辑调用成功直接返回</li>
<li>8c:降级逻辑调用失败抛出异常</li>
</ul>
</li>
<li>9:返回执行成功结果</li>
</ul>
<h5 id="2-熔断器-Circuit-Breaker"><a href="#2-熔断器-Circuit-Breaker" class="headerlink" title="2):熔断器:Circuit Breaker"></a>2):熔断器:Circuit Breaker</h5><p>Circuit Breaker 流程架构和统计<br><img src="http://i3.itc.cn/20160816/3084_f28d342a_faf8_cfc7_de53_3cbfae9efeec_1.png" alt=""></p>
<p>每个熔断器默认维护10个bucket,每秒一个bucket,每个blucket记录成功,失败,超时,拒绝的状态，<br>默认错误超过50%且10秒内超过20个请求进行中断拦截.<br>更多熔断器的原理请见wiki： CircuitBreaker(熔断器)设计实现</p>
<h5 id="3-隔离-Isolation-分析"><a href="#3-隔离-Isolation-分析" class="headerlink" title="3)隔离(Isolation)分析"></a>3)隔离(Isolation)分析</h5><p>Hystrix隔离方式采用线程/信号的方式,通过隔离限制依赖的并发量和阻塞扩散.</p>
<h6 id="1-线程隔离"><a href="#1-线程隔离" class="headerlink" title="(1):线程隔离"></a>(1):线程隔离</h6><pre><code>把执行依赖代码的线程与请求线程(如:jetty线程)分离，请求线程可以自由控制离开的时间(异步过程)。
</code></pre><p>   通过线程池大小可以控制并发量，当线程池饱和时可以提前拒绝服务,防止依赖问题扩散。<br>   线上建议线程池不要设置过大，否则大量堵塞线程有可能会拖慢服务器。</p>
<h6 id="2-线程隔离的优缺点"><a href="#2-线程隔离的优缺点" class="headerlink" title="(2):线程隔离的优缺点"></a>(2):线程隔离的优缺点</h6><p>线程隔离的优点:</p>
<ul>
<li>[1]:使用线程可以完全隔离第三方代码,请求线程可以快速放回。</li>
<li>[2]:当一个失败的依赖再次变成可用时，线程池将清理，并立即恢复可用，而不是一个长时间的恢复。</li>
<li>[3]:可以完全模拟异步调用，方便异步编程。</li>
</ul>
<p>线程隔离的缺点:</p>
<ul>
<li>[1]:线程池的主要缺点是它增加了cpu，因为每个命令的执行涉及到排队(默认使用SynchronousQueue避免排队)，调度和上下文切换。</li>
<li>[2]:对使用ThreadLocal等依赖线程状态的代码增加复杂性，需要手动传递和清理线程状态。<br>NOTE: Netflix公司内部认为线程隔离开销足够小，不会造成重大的成本或性能的影响。<br>Netflix 内部API 每天100亿的HystrixCommand依赖请求使用线程隔，每个应用大约40多个线程池，每个线程池大约5-20个线程。</li>
</ul>
<h6 id="3-信号隔离"><a href="#3-信号隔离" class="headerlink" title="(3):信号隔离"></a>(3):信号隔离</h6><p>   信号隔离也可以用于限制并发访问，防止阻塞扩散, 与线程隔离最大不同在于执行依赖代码的线程依然是请求线程（该线程需要通过信号申请）,<br>   如果客户端是可信的且可以快速返回，可以使用信号隔离替换线程隔离,降低开销.<br>   信号量的大小可以动态调整, 线程池大小不可以.<br>线程隔离与信号隔离区别如下图:<br><img src="http://i3.itc.cn/20160816/3084_323c1e07_1bca_58f8_04fc_759d33087ccf_1.png" alt=""></p>
<p>图片出自官网wiki , 更多内容请见官网: <a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a></p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/17/rocketmq设计与分析(2)--简介/" rel="prev" title="rocketmq设计与分析(2)--存储层">
                rocketmq设计与分析(2)--存储层 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/17/Hystrix 使用与分析/"
           data-title="Hystrix 使用与分析" data-url="http://yoursite.com/2016/08/17/Hystrix 使用与分析/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://i3.itc.cn/20160316/3084_9587fc69_5909_9fac_89e3_c420eda9eafa_1.png"
               alt="sohutv" />
          <p class="site-author-name" itemprop="name">sohutv</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sohutv/cachecloud" target="_blank" title="github">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-为什么需要Hystrix"><span class="nav-number">1.</span> <span class="nav-text">一:为什么需要Hystrix?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-Hystrix如何解决依赖隔离"><span class="nav-number">2.</span> <span class="nav-text">二:Hystrix如何解决依赖隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-如何使用Hystrix"><span class="nav-number">3.</span> <span class="nav-text">三:如何使用Hystrix</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-使用maven引入Hystrix依赖"><span class="nav-number">3.1.</span> <span class="nav-text">1:使用maven引入Hystrix依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-使用命令模式封装依赖逻辑"><span class="nav-number">3.2.</span> <span class="nav-text">2:使用命令模式封装依赖逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-注册异步事件回调执行"><span class="nav-number">3.3.</span> <span class="nav-text">3:注册异步事件回调执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-使用Fallback-提供降级策略"><span class="nav-number">3.4.</span> <span class="nav-text">4:使用Fallback() 提供降级策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-依赖命名-CommandKey"><span class="nav-number">3.5.</span> <span class="nav-text">5:依赖命名:CommandKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-依赖分组-CommandGroup"><span class="nav-number">3.6.</span> <span class="nav-text">6:依赖分组:CommandGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-线程池-信号-ThreadPoolKey"><span class="nav-number">3.7.</span> <span class="nav-text">7:线程池/信号:ThreadPoolKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-请求缓存-Request-Cache"><span class="nav-number">3.8.</span> <span class="nav-text">8:请求缓存 Request-Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-信号量隔离-SEMAPHORE"><span class="nav-number">3.9.</span> <span class="nav-text">9:信号量隔离:SEMAPHORE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-fallback降级逻辑命令嵌套"><span class="nav-number">3.10.</span> <span class="nav-text">10:fallback降级逻辑命令嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-显示调用fallback逻辑-用于特殊业务处理"><span class="nav-number">3.11.</span> <span class="nav-text">11:显示调用fallback逻辑,用于特殊业务处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-命令调用合并-HystrixCollapser"><span class="nav-number">3.12.</span> <span class="nav-text">12:命令调用合并:HystrixCollapser</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-监控平台搭建Hystrix-dashboard"><span class="nav-number">4.</span> <span class="nav-text">四:监控平台搭建Hystrix-dashboard</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-监控dashboard介绍"><span class="nav-number">4.1.</span> <span class="nav-text">1:监控dashboard介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-实例暴露command统计数据"><span class="nav-number">4.2.</span> <span class="nav-text">2:实例暴露command统计数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-集群模式监控统计搭建"><span class="nav-number">4.3.</span> <span class="nav-text">3:集群模式监控统计搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-使用Turbine组件做集群数据汇总"><span class="nav-number">4.3.1.</span> <span class="nav-text">1)使用Turbine组件做集群数据汇总</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内嵌jetty提供Servlet容器-暴露HystrixMetrics"><span class="nav-number">4.3.2.</span> <span class="nav-text">2)内嵌jetty提供Servlet容器,暴露HystrixMetrics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Turbine搭建和配置"><span class="nav-number">4.3.3.</span> <span class="nav-text">3)Turbine搭建和配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-Hystrix配置与分析"><span class="nav-number">5.</span> <span class="nav-text">五:Hystrix配置与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Hystrix-配置"><span class="nav-number">5.1.</span> <span class="nav-text">1:Hystrix 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Command-配置"><span class="nav-number">5.1.1.</span> <span class="nav-text">1):Command 配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-熔断器（Circuit-Breaker）配置"><span class="nav-number">5.1.2.</span> <span class="nav-text">2):熔断器（Circuit Breaker）配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-命令合并-Collapser-配置"><span class="nav-number">5.1.3.</span> <span class="nav-text">3):命令合并(Collapser)配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-线程池-ThreadPool-配置"><span class="nav-number">5.1.4.</span> <span class="nav-text">4):线程池(ThreadPool)配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Hystrix关键组件分析"><span class="nav-number">5.2.</span> <span class="nav-text">2:Hystrix关键组件分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Hystrix流程结构解析"><span class="nav-number">5.2.1.</span> <span class="nav-text">1):Hystrix流程结构解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-熔断器-Circuit-Breaker"><span class="nav-number">5.2.2.</span> <span class="nav-text">2):熔断器:Circuit Breaker</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-隔离-Isolation-分析"><span class="nav-number">5.2.3.</span> <span class="nav-text">3)隔离(Isolation)分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-线程隔离"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">(1):线程隔离</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-线程隔离的优缺点"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">(2):线程隔离的优缺点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-信号隔离"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">(3):信号隔离</span></a></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sohutv</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cachecloud"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
